<!DOCTYPE HTML>
<html>

<head>
	<title>"com.threesixtydev.sfx</title>
    <meta charset="utf-8" />
</head>

<body>
    <script>
    	var interval = {};
    	var websocket = null;
    	var pluginUUID = null;
    	
    	var DestinationEnum = Object.freeze({"HARDWARE_AND_SOFTWARE":0, "HARDWARE_ONLY":1, "SOFTWARE_ONLY":2})
    	
        var timer;
		var settings_collection = {};
        
		function loadImage (inUrl, callback, inCanvas, inFillcolor) {
			/** Convert to array, so we may load multiple images at once */
			const aUrl = !Array.isArray(inUrl) ? [inUrl] : inUrl;
			const canvas = inCanvas && inCanvas instanceof HTMLCanvasElement
				? inCanvas
				: document.createElement('canvas');
			var imgCount = aUrl.length - 1;
			const imgCache = {};

			var ctx = canvas.getContext('2d');
			ctx.globalCompositeOperation = 'source-over';

			for (let url of aUrl) {
				let image = new Image();
				let cnt = imgCount;
				let w = 144, h = 144;

				image.onload = function () {
					imgCache[url] = this;
					// look at the size of the first image
					if (url === aUrl[0]) {
						canvas.width = this.naturalWidth; // or 'width' if you want a special/scaled size
						canvas.height = this.naturalHeight; // or 'height' if you want a special/scaled size
					}
					// if (Object.keys(imgCache).length == aUrl.length) {
					if (cnt < 1) {
						if (inFillcolor) {
							ctx.fillStyle = inFillcolor;
							ctx.fillRect(0, 0, canvas.width, canvas.height);
						}
						// draw in the proper sequence FIFO
						aUrl.forEach(e => {
							if (!imgCache[e]) {
								console.warn(imgCache[e], imgCache);
							}

							if (imgCache[e]) {
								ctx.drawImage(imgCache[e], 0, 0);
								ctx.save();
							}
						});

						callback(canvas.toDataURL('image/png'));
						// or to get raw image data
						// callback && callback(canvas.toDataURL('image/png').replace(/^data:image\/(png|jpg);base64,/, ''));
					}
				};

				imgCount--;
				image.src = url;
			}
		};

		function loadAndSetImage (context, imageNameOrArr) {
			loadImage(imageNameOrArr, function (data) {
				var json = {
					'event': 'setImage',
					'context': context,
					'payload': {
						'image': data,
						'target': DestinationEnum.HARDWARE_AND_SOFTWARE
					}
				};
				websocket.send(JSON.stringify(json));
			});
		};

		function update_button(context, orgid, token) {
			console.log("Updating From SFX", context, orgid, token);
			
			fetch("https://app.signalfx.com/v1/eventtimeseries?query=sf_organizationID%3A" + orgid + "%20AND%20(NOT%20sf_archived%3Atrue)%20%20AND%20(((sf_anomalyState%3A(%22anomalous%22%20OR%20%22too%20high%22%20OR%20%22too%20low%22))))&getAggregation=true&terms=sf_severity", {'headers':{"X-SF-TOKEN": token}})
				.then(response => {
					if (!response.ok) {
						counterAction.ShowAlert(context)
						loadAndSetImage(context, "Disconnected.png")
						stop_updates(context)
						return null
					}
					return response.json()
				})
				.then(data => {
					if (!data) {
						return
					}
					var aggs = data.aggregations
					
					var counts = {};
					for (var i = 0; i < aggs.length; i++) {
						var item = aggs[i];
						counts[item['name']] = item['count'];
					}
					console.log("Counts", counts);

					if(counts['Critical'] > 0)
					{
						loadAndSetImage(context, "Critical.png")
						counterAction.SetTitle(context, counts["Critical"]);
					}
					else if(counts['Major'] > 0)
					{
						loadAndSetImage(context, "Major.png")
						counterAction.SetTitle(context, counts["Major"]);
					}
					else if(counts['Minor'] > 0)
					{
						loadAndSetImage(context, "Minor.png")
						counterAction.SetTitle(context, counts["Minor"]);
					}
					else if(counts['Warning'] > 0)
					{
						loadAndSetImage(context, "Warning.png")
						counterAction.SetTitle(context, counts["Warning"]);
					}
					else if(counts['Info'] > 0)
					{
						loadAndSetImage(context, "Info.png")
						counterAction.SetTitle(context, counts["Info"]);
					}
					else{
						loadAndSetImage(context, "Ok.png")
						counterAction.SetTitle(context, "0");
					}
				});
		}

		function restart_updates(context, settings)
		{
			if (!(context in interval))
			{
				interval[context] = null;
			}
			if (!("org-id" in settings) || !settings["org-id"])
			{
				counterAction.ShowAlert(context)
				loadAndSetImage(context, "Disconnected.png")
				return
			}
			if (!("x-sf-token" in settings) || !settings["x-sf-token"])
			{
				counterAction.ShowAlert(context)
				loadAndSetImage(context, "Disconnected.png")
				return
			}
			if (interval[context] !== null) {
				clearInterval(interval[context]);
			}
			update_button(context, settings['org-id'], settings['x-sf-token']);
			interval[context] = setInterval(update_button, 60000, context, settings['org-id'], settings['x-sf-token']);
		}

		function stop_updates(context)
		{
			if (interval[context] !== null) {
				clearInterval(interval[context]);
			}
		}

    	var counterAction = {
			
			type : "com.threesixtydev.sfx.action",
			
			onKeyDown : function(context, settings, coordinates, userDesiredState) {
              
			},
			
			onKeyUp : function(context, settings, coordinates, userDesiredState) {
				console.log("Opening SFX", settings)
				if (!("org-id" in settings) || !settings["org-id"])
				{
					this.ShowAlert(context)
					return
				}
				this.OpenURL("https://app.signalfx.com/#/alerts/" + settings["org-id"])
			},
			
			onWillAppear : function(context, settings, coordinates) {
				console.log("appearing", settings)
				restart_updates(context, settings)
			},

			onWillDisappear : function(context, settings, coordinates) {
				console.log("disappearing", settings)
				stop_updates(context)
			},
			
			SetTitle : function(context, title_string) {
				var json = {
					"event": "setTitle",
					"context": context,
					"payload": {
						"title": "" + title_string,
						"target": DestinationEnum.HARDWARE_AND_SOFTWARE
					}
				};
			
				websocket.send(JSON.stringify(json));
			 },

			OpenURL : function(url) {
				var json = {
					"event": "openUrl",
					"payload": {
						"url": url
					}
				};
			
				websocket.send(JSON.stringify(json));
			 },
			 
			ShowAlert : function(context) {
				var json = {
					"event": "showAlert",
					"context": context,
				};
			
				websocket.send(JSON.stringify(json));
			 },
			 
			 SetSettings : function(context, settings) {
				var json = {
					"event": "setSettings",
					"context": context,
					"payload": settings
				};
			
				websocket.send(JSON.stringify(json));
				restart_updates(context, settings)
			 }
		};
    	
        function connectElgatoStreamDeckSocket(inPort, inPluginUUID, inRegisterEvent, inInfo)
         {
         	pluginUUID = inPluginUUID
         	
			// Open the web socket
			websocket = new WebSocket("ws://127.0.0.1:" + inPort);
			
			function registerPlugin(inPluginUUID)
			 {
				var json = {
					"event": inRegisterEvent,
					"uuid": inPluginUUID
				};
			
				websocket.send(JSON.stringify(json));
			 };
			
			websocket.onopen = function()
			{
				// WebSocket is connected, send message
				registerPlugin(pluginUUID);
			};

			websocket.onmessage = function (evt)
			{ 
				// Received message from Stream Deck
				var jsonObj = JSON.parse(evt.data);
				var event = jsonObj['event'];
				var action = jsonObj['action'];
				var context = jsonObj['context'];
				
				if(event == "keyDown")
				{
					var jsonPayload = jsonObj['payload'];
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					var userDesiredState = jsonPayload['userDesiredState'];
					counterAction.onKeyDown(context, settings, coordinates, userDesiredState);
				}
				else if(event == "keyUp")
				{
					var jsonPayload = jsonObj['payload'];
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					var userDesiredState = jsonPayload['userDesiredState'];
					counterAction.onKeyUp(context, settings, coordinates, userDesiredState);
				}
				else if(event == "willAppear")
				{
					var jsonPayload = jsonObj['payload'];
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					counterAction.onWillAppear(context, settings, coordinates);
				}
				else if(event == "willDisappear")
				{
					var jsonPayload = jsonObj['payload'];
					var settings = jsonPayload['settings'];
					var coordinates = jsonPayload['coordinates'];
					counterAction.onWillDisappear(context, settings, coordinates);
				}
				else if(event == "sendToPlugin")
				{
					console.log("sendToPlugin", jsonObj)
					var jsonPayload = jsonObj['payload'];
					if ('sdpi_collection' in jsonPayload)
					{
						var sdpi_collection = jsonPayload['sdpi_collection']
						if (!(context in settings_collection))
						{
							settings_collection[context] = {}
						}
						settings_collection[context][sdpi_collection['key']] = sdpi_collection['value'];
						counterAction.SetSettings(context, settings_collection[context]);
					}
				}
				else
				{
					console.log("Unhandled Event:", event)
				}
			};

			websocket.onclose = function()
			{ 
				// Websocket is closed
			};
         };
         
         
         
         
    </script>

</body>

</html>
